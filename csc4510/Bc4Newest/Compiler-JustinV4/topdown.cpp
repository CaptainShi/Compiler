/*
Authors: Cole Burkhart, Jacky Shi, Justin Weiss 
Date: 4/23/2019
Class: CSC 4510-01
BC Version 4 - Recursive descent parser
Uses grammar rules to parser statement that are entered in from the keyboard or input redirection

*/
#include "general_ex.h"
#include <iostream>
#include <stdio.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "symbolTable.h"

//Global symbol table and pointers
extern Symbol_table table;
extern Symbol_ptr symbol_ptr;
Symbol_ptr symbol_ptr2;

using namespace std;

/*stmt
Parses strings inthe langauge generated by the rule:
<stmt> -> id = <expr>
       | if <cond> then <stmts> <optional_else>
       | while <cond> do <stmts> done
       | print id
       | #comment
       | QUIT
       | DUMP
*/
int stmt()
{
    //sets local int and pointer values
    int value = 0;
    Symbol_ptr s_ptr;
    Symbol_ptr p_ptr;

   //Print rule
   //prints the desired variable to the screen
   if(nextToken == PRINT){
      lex();
      p_ptr = table.lookup(lexeme);
      cout << "PRINT" << endl;
      cout << "        " << p_ptr->getid() << "=" << p_ptr->getval() << endl;
      p_ptr = NULL;
   }


    //if the next token is 'if'
    //Process an if statement 
    if (nextToken == IF) {
       lex();
 
       //calls cond() to get a true or false value
       bool condition = cond();
 
      //Checks if the condition is true
      //if it is then processes the statement following the then
      if (condition == 1) {
         
         //Checks if the nextToken is then
         if (nextToken == THEN) {
            lex();
            //stores the value
            int value = stmt();
         }
      }
      
      //Processes until and else or fi
      while (nextToken != ELSE && nextToken != FI) {
         lex();
      }
    
      //Calls optionalElse to process and else statement or finish the if
      optionalElse();

    } //End if processing


    //While case
    //Processes a while loop
    if(nextToken == WHILE){
 
       //sets string index to 0
       string_index = 0;
       //gets the position of the condition
       curr_index = program.length();
       lex();
   
       //gets a true or false value
       bool condition = cond();

       //if cond is true
       if(condition == 1){
          
           //checks if nextToken is do
           if(nextToken == DO){
              lex();
              do {
   
                //process all statements until you reach the done token
                while(nextToken != DONE){
                   if(nextToken != DONE){
                      int value = stmt();
                      getChar();
                      lex();
                   }
                }

              //if nextToken is done
              if(nextToken == DONE){
                 inwhile = true;
                 string_index = curr_index;
                 getChar();
                 lex();
                 condition = cond();
               }

             //While loop that runs until the condition is false
             } while(condition == 1);
   
             //sets the inwhile check to false
             inwhile = false;

           }
       } 
    } //End while processing

    lex();

    //Assignment case
    //if nextToken is equal
    if (nextToken == EQUAL) {

      //sets up local pointer
       s_ptr = symbol_ptr;
       lex();
 
       //gets the value
       value = expr();

       //loads into symbol table
       s_ptr->putval(value);
         
       symbol_ptr = NULL;
    }//Ends assignment


    //if the nextoken is dump then dump the table
    if (nextToken == DUMP) {
       cout << "Dump" << endl;
       cout << "================" << endl;
       table.dump_table();
       cout << "================" << endl;
    }

    //if the next token is quit then quit the table
    if(nextToken == QUIT){
      nextToken = EOF;
      exit(1);
   }

    return value;

}
/* expr
 Parses strings in the language generated by the rule:
 <expr> -> <term> {(+ | -) <term>}
 */
int expr()
{
    int value1 = 0;
    int value2 = 0;

    /* Parse the first factor */
    value1 = term();
    /* As long as the next token is + or -, get the
    next token and parse the next factor */

    while (nextToken == ADD_OP || nextToken == SUB_OP) {
       if (nextToken == ADD_OP) {
          lex();
          value2 = term();
          value1 = value1 + value2;
       } else if(nextToken == SUB_OP){
          lex();
          value2 = term();
          value1 = value1 - value2;
       } else {
          cout << "Token Error in expr()" << endl;
       }
       lex();
    }
    return value1;


} /* End of function expr */
/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
int term()
{
    int value1 = 0;
    int value2 = 0;

    /* Parse the first factor */
    value1 = negatives();

    /* As long as the next token is * or / or %, get the
     next token and parse the next factor */
     while (nextToken == MULT_OP || nextToken == DIV_OP || nextToken == MOD) {
        if (nextToken == MULT_OP){
           lex();
           value2 = factor();
           value1 = value1 * value2;
        } else if(nextToken == DIV_OP){
           lex();
           value2 = factor();
           if(value2 == 0){
             cout << "Error attempting division by 0" << endl;
             value1 = 0;
           }
           else
              value1 = value1 / value2;
        } else if(nextToken == MOD){
           lex();
           value2 = factor();
           value1 = value1 % value2;
        } else {
           cout << "Token error in term()" << endl;
        }
        lex();
     }

     return value1;

} /* End of function term */
/* factor
 * Parses strings in the language generated by the rule:
 *
 * <factor> -> id | int_constant | ( <expr )
 *
 */
int factor()
{

    //If it is a number
    //return it
    if (nextToken == INT_LIT){
       return atoi(lexeme);
    }

    //if is ident
    else if (nextToken == IDENT){
       /* Get the next token */

        //if there is a value
        int result;
        result = symbol_ptr->getval();
        //then return
        return result;
    }

    /* If the RHS is ( <expr> ), call lex to pass over the left
    parenthesis, call expr and check for the right parenthesis */
    else if (nextToken == LEFT_PAREN) {
       lex();
       int value = expr();
       if (nextToken == RIGHT_PAREN){
          return value;
          }

       else
          error("Right without left paren");
    }
    else {
       /* It was not an id, an integer literal, or a left
       parenthesis */
       error("expected an id, integer, or a left paren");
       return 0;
    } /* End of else */


}/* End of function factor */

//Checks for unary minus
//if there is one then mult the value by -1
int negatives() {
   
   int value = 0;

   //will return a negative number
   if (nextToken == SUB_OP){
       lex();
       value = powers();
       value *= -1;
   } else {
       value = powers();
   }
   return value;
}

//Calculate exponments
//returns the power
int powers()
{
//will return a number that has been raised to a power

   int value1 = factor();
   lex();

   //gets the exponents
   while(nextToken == EXPO){
      lex();
      int value2 = factor();
      value1 = pow(value1, value2);
      lex();
   }

   return value1;

}

/* Condition function
checks for various condtitions such as less than, greater than, etc
*/
bool cond() {
 
    //local variables
    char Oper;
    int value1 = 0;
    int value2 = 0;

    //gets first values
    value1 = expr();
    
    //Gets the operator 
    Oper = nextToken;

    lex();

    //Gets the secound variable
    value2 = expr();

    //Series of if statements that checks for the various comparison ops
    //if you find one the sets the nextToken to that operator
    //Returns a true or false

    if (Oper == EE) {
        cout << "EE" << endl;
        if (value1 == value2) {
            return true;
        } else return false;
    } else if (Oper == NE) {
        if (value1 == value2) {
            return false;
        } else return true;
    } else if (Oper == LESSTHEN) {
        if (value1 < value2) {
            return true;
        } else return false;
    } else if (Oper == GREATERTHEN) {
        if (value1 > value2) {
          return true;
        } else return false;
    } else if (Oper == LE) {
        if (value1 <= value2) {
          return true;
        } else return false;
    } else if (Oper == GE) {
        if (value1 >= value2) {
          return true;
        } else return false;
    } else {
        cout << "Ooops, there is a problem" << endl;
        return false;
    }
}

//Optional else
//Process the else part of the if statement
//or the fi part of a normal if
//returns nothing
void optionalElse() {
   
   //checks for fi token
   if (nextToken == FI) {

   //checks for else token
   } else if (nextToken == ELSE) {
      lex();
      int value = stmt();
   } else {
      cout << "Whoops, we got a problem in optional else" << endl;
   }
}

//Prints error message
void error(const char *message)
{
    printf("Error: %s\n",message);
}
